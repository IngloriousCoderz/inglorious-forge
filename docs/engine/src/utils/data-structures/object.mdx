import { Meta } from '@storybook/addon-docs/blocks'

import { toString as bToString } from '@inglorious/utils/data-structures/boolean'
import {
  clone,
  filter,
  find,
  get,
  deserialize,
  isObject,
  map,
  set,
  produce,
  serialize,
  toString,
} from '@inglorious/utils/data-structures/object'
import { v } from '@inglorious/utils/v'

<Meta title="Utils/Data Structures/Object" />

# Object

Functions that deal with a single object.

## Clone

Creates a deep clone of a value. It uses `structuredClone()` internally, so it has the same limitations (e.g., it will not clone functions, DOM nodes, or other non-serializable objects).

### Usage

```javascript
const obj = { a: 1, b: [2, 3], c: { d: 4 } };
const clonedObj = clone(obj);

console.log(clonedObj); // { a: 1, b: [2, 3], c: { d: 4 } }
console.log(obj.c === clonedObj.c); // false
```

## Deserialize

Recursively converts a JSON string back into a JavaScript object, automatically re-hydrating any `_type: 'vector'` objects into `v()` vectors. This is the counterpart to the `serialize` function, ensuring that the original functionality of the vectors is restored after network transfer.

### Usage

```javascript
import { deserialize } from '@inglorious/utils/data-structures/object';

const packet = '{"position":{"_type":"vector","coords":[10,20,30]},"color":{"_type":"vector","coords":[255,0,0,1]},"inventory":["sword","shield"]}';

const player = deserialize(packet);

// player.position is now a v() vector object
console.log(player.position.__isVector__); // true

// You can now perform vector operations in IngloriousScript
const newPos = player.position + v(1, 1, 1);
console.log(newPos); // [11, 21, 31]
```

## Filter

Behaves similarly to `Array.prototype.filter`, returning an object that contains only properties that satisfy the given predicate.

### Usage

```javascript
const obj = { key1: 'value1', key2: 'value2', key3: 'value3' };
const predicate = (key) => ['key2', 'key3'].includes(key);
filter(obj, predicate); // { key2: 'value2', key3: 'value3' }
```

## Find

Behaves similarly to `Array.prototype.find`, returning an object that contains only the first property that satisfies the given predicate.

### Usage

```javascript
const obj = { key1: 'value1', key2: 'value2', key3: 'value3' };
const predicate = (key) => ['key2', 'key3'].includes(key);
find(obj, predicate); // { key2: 'value2' }
```

## Get

Gets the value at a specified path of an object using dot-notation. If the resolved value is `undefined`, the `defaultValue` is returned in its place. This is similar to Lodash's `_.get`.

### Usage

```javascript
import { get } from '@inglorious/utils/data-structures/object';

const object = { 'a': [{ 'b': { 'c': 3 } }] };

get(object, 'a.0.b.c'); // => 3
get(object, 'a.0.d', 'default'); // => 'default'
```

## Is Object

Checks if a value is a plain JavaScript object. This function returns false for arrays, null, and other object types like Date.

### Usage

```javascript
isObject({}); // true
isObject([]); // false
isObject(null); // false
isObject(new Date()); // false
```

## Map

Behaves similarly to `Array.prototype.map`, returning an object that has values transformed according to the given callback.

### Usage

```javascript
const obj = { key1: 'value1', key2: 'value2', key3: 'value3' };
const callback = (key, value) => value.toUpperCase();
map(obj, callback); // { key1: 'VALUE1', key2: 'VALUE2', key3: 'VALUE3' }
```

## Produce

A utility function inspired by Immer's `produce` API. It provides a convenient way to work with immutable data structures by allowing "mutations" on a temporary draft.

### Important Performance Note

Unlike libraries like Immer or Mutative, which use structural sharing via proxies for high performance, this implementation performs a **full deep clone** of the base state on every call using `structuredClone()`.

This can be very inefficient for large or complex states. It is intended for simple use cases where the convenience of the API outweighs the performance cost. For performance-critical state updates, consider using a library like Mutative directly.

### How It Works

The `recipe` function receives a draft copy of the state. It can either mutate the draft and return nothing (`undefined`), or it can return a completely new value, which will become the next state.

### Usage

The function can be called in two ways:

#### Standard Call

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const baseState = {
  user: { name: 'Alice', age: 30 },
  posts: [],
};

const nextState = produce(baseState, (draft) => {
  draft.user.age += 1;
  draft.posts.push({ id: 1, title: 'Hello World' });
});

console.log(nextState.user.age); // 31
console.log(baseState.user.age); // 30 (original state is untouched)
```

#### Curried Call

You can also create a reusable producer function by passing only the recipe.

```javascript
import { produce } from '@inglorious/utils/data-structures/object';

const incrementAge = produce((draft) => {
  draft.user.age += 1;
});

const state1 = { user: { name: 'Alice', age: 30 } };
const state2 = incrementAge(state1);

console.log(state2.user.age); // 31
console.log(state1.user.age); // 30
```

## Serialize

Recursively converts an object containing `v()` vectors into a JSON string suitable for network transfer. This process replaces `v()` vector objects (which are arrays with a `__isVector__` property) with a plain object containing a `_type` and `coords` property.

This ensures that the vector's type information is preserved during serialization, preventing bugs in networked applications.

### Usage

```javascript
import { serialize } from '@inglorious/utils/data-structures/object';
import { v } from '@inglorious/utils/v';

const player = {
  position: v(10, 20, 30),
  color: v(255, 0, 0, 1),
  inventory: ['sword', 'shield']
};

const packet = serialize(player);

console.log(packet);
// Expected output (as a string)
// '{"position":{"_type":"vector","coords":[10,20,30]},"color":{"_type":"vector","coords":[255,0,0,1]},"inventory":["sword","shield"]}'
```

## Set

Sets the value at a specified path of an object. If a portion of the path doesn't exist, it's created. Arrays are created for missing index properties, while objects are created for all other missing properties. This function mutates the object and is similar to Lodash's `_.set`.

### Usage

```javascript
import { set } from '@inglorious/utils/data-structures/object';

const object = { 'a': [{ 'b': { 'c': 3 } }] };

set(object, 'a.0.b.d', 4);
// object is now { 'a': [{ 'b': { 'c': 3, 'd': 4 } }] }
 
set(object, 'x.0.y', 5);
// object is now { 'a': [...], 'x': [{ 'y': 5 }] }
```

## To String

Converts an object or array to a formatted string representation with indentation. This is useful for pretty-printing data for debugging or logging.

### Usage

```javascript
const obj = { a: 1, b: [2, 3], c: { d: 4 } };

console.log(toString(obj));
/*
{
  a: 1,
  b: [
    2,
    3
  ],
  c: {
    d: 4
  }
}
*/
```
