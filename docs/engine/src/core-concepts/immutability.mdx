import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Engine/Core Concepts/Immutability" />

# Immutability

The engine's state is **immutable**. This means that you cannot change the state directly. Instead, you must `notify` the engine of events that describe the changes you want to make.

## Why Immutability?

Developing with immutable data encourages you to think differently about how data flows through your application. It leads to:
-   **Predictable State Changes:** State can only change in response to events, making it easier to reason about and debug.
-   **Performance Optimizations:** It's easy to detect if the state has changed by simply checking for reference equality (`===`). This is used by UI libraries like React to avoid unnecessary re-renders.
-   **Time-Travel Debugging:** Since each state is a separate object, you can store a history of states and "travel" back and forth, which is a powerful debugging tool provided by the Redux DevTools.

## Working with Immutable State

The engine uses the **[Mutative](https://mutative.js.org/)** library to manage its state. This provides a powerful and convenient way to work with immutable data.

### Mutating the Current Entity

Inside an event handler (like `update`, `start`, or `mouseClick`), the **first parameter** is a special, mutable "draft" of the entity handling the event. You can change its properties directly. Mutative will safely record these changes and produce a new, immutable state without you having to worry about it.

```javascript
// Inside a behavior
{
  update(entity, dt, api) {
    // `entity` is a mutable draft. You can change it directly.
    entity.position[0] += entity.velocity[0] * dt;
    entity.position[2] += entity.velocity[2] * dt;
  }
}
```

This makes writing update logic feel natural, while still getting all the benefits of immutability.

_(By the way, you can also use vector operations to make your code more readable and concise)_

```javascript
{
  update(entity, dt, api) {
    entity.position = add(entity.position, scale(entity.velocity, dt))
  }
}
```

### Interacting with Other Entities

When you need to interact with a *different* entity, you retrieve it using the `api`, for example `api.getEntity('player')`.

**Entities retrieved from the `api` are read-only.**

Because the state is frozen by Mutative, any attempt to directly mutate an entity retrieved from the `api` will fail and throw a `TypeError`.

```javascript
// This will throw a TypeError because the state is frozen.
const player = api.getEntity('player');
player.health -= 10; // ‚ùå ERROR!
```

This built-in protection from Mutative ensures that the immutable data flow is always respected, making your game more robust and predictable.
